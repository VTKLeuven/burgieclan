# Number of nginx worker processes (1 is fine for containerized apps)
worker_processes  1;

events {
    # Maximum number of simultaneous connections per worker
    worker_connections  1024;
}

http {
    # Load MIME types for proper content-type headers
    include       mime.types;
    
    # Enable sendfile for efficient file transfers
    sendfile        on;
    
    # How long to keep connections alive (in seconds)
    keepalive_timeout  65;

    server {
        # Listen on port specified by LISTEN_PORT placeholder (replaced at runtime)
        # default_server makes this the fallback for unmatched requests
        listen LISTEN_PORT default_server;
        
        # Enable HTTP/2 protocol for better performance
        http2 on;
        
        # Accept requests for any hostname (wildcard)
        server_name _;
        
        # Symfony's public directory is the web root
        root /app/public;
        
        # Default file to serve
        index index.php;
        
        # Use UTF-8 encoding
        charset utf-8;
        
        # Main location block - handles all requests
        location / {
            # Try to serve file directly, then directory, then pass to Symfony front controller
            # $is_args$args preserves query strings (e.g., ?foo=bar)
            try_files $uri $uri/ /index.php$is_args$args;
        }

        # Don't log requests for favicon and robots.txt (reduces log noise)
        location = /favicon.ico { access_log off; log_not_found off; }
        location = /robots.txt  { access_log off; log_not_found off; }
        
        # Send logs to stdout/stderr for Docker (container logging standard)
        access_log /dev/stdout;
        error_log /dev/stderr;
        
        # Disable sendfile in this context (can cause issues in some environments)
        sendfile off;
        
        # Maximum upload size (100MB for file uploads)
        client_max_body_size 500m;

        # PHP file handler - processes .php files through PHP-FPM
        location ~ \.php$ {
            # Split the URI into script filename and path info
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            
            # Forward to PHP-FPM listening on localhost:9000
            fastcgi_pass 127.0.0.1:9000;
            
            # Default PHP file to execute
            fastcgi_index index.php;
            
            # Include standard FastCGI parameters
            include fastcgi_params;
            
            # Set the script filename for PHP-FPM to execute
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            
            # Don't intercept errors (let PHP handle them)
            fastcgi_intercept_errors off;
            
            # Disable buffering for faster response streaming
            fastcgi_buffering off;
        }

        # Custom error pages for 5xx server errors
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }
}

# Don't run nginx as daemon - keep it in foreground for Docker
# This prevents the container from exiting immediately
daemon off;
