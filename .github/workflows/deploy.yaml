name: "Deploy Stack (Frontend + Backend)"

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
      url:
        type: string
        required: true
    secrets:
      SSH_USER:
        required: true
      SSH_HOST:
        required: true
      SSH_PRIVATE_KEY:
        required: true

jobs:
  build_backend:
    name: Build Backend
    uses: ./.github/workflows/build-backend.yaml
    with:
      environment: ${{ inputs.environment }}

  build_frontend:
    name: Build Frontend
    uses: ./.github/workflows/build-frontend.yaml
    with:
      environment: ${{ inputs.environment }}

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [build_backend, build_frontend]
    environment:
      name: ${{ inputs.environment }}
      url: ${{ inputs.url }}

    steps:
      - name: Setup SSH access
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          install -m 600 -D /dev/null ~/.ssh/id_rsa
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          ssh-keyscan -H "$SSH_HOST" > ~/.ssh/known_hosts

      - name: Pull and deploy containers
        env:
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          ssh "$SSH_USER@$SSH_HOST" << 'EOF'
            # Variables
            DEPLOY_DIR="${{ vars.DEPLOY_DIR }}"
            COMPOSE_FILE="$DEPLOY_DIR/.docker/docker-compose.prod.yml"
            
            # Change to deployment directory
            cd $DEPLOY_DIR
            
            # Ensure data directory is present
            if [ ! -d ${{ vars.DATA_DIR }} ]; then
              echo "❌ Data directory does not exist"
              exit 1
            fi

            # Ensure JWT directory is present
            if [ ! -d ${{ vars.JWT_DIR }} ]; then
              echo "❌ JWT directory does not exist"
              exit 1
            fi
            # Ensure JWT keys (public and private) are present
            if [ ! -f ${{ vars.JWT_DIR }}/private.pem ] || [ ! -f ${{ vars.JWT_DIR }}/public.pem ]; then
              echo "❌ JWT keys do not exist"
              exit 1
            fi
            
            # Log in to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull the latest images (backend and frontend)
            docker compose -f $COMPOSE_FILE pull
            
            # Stop and remove old containers
            docker compose -f $COMPOSE_FILE down
            
            # Start new containers with latest images
            docker compose -f $COMPOSE_FILE up -d --force-recreate --wait --wait-timeout 30s
            
            # Verify all services are healthy
            if docker compose -f $COMPOSE_FILE ps --format json | jq -e 'all(.Health == "healthy" or .Health == "")' > /dev/null; then
              echo "✅ All containers healthy"
              docker compose -f $COMPOSE_FILE ps
            else
              echo "❌ Some containers unhealthy"
              docker compose -f $COMPOSE_FILE ps
              docker compose -f $COMPOSE_FILE logs
              exit 1
            fi
            
            # Run database migrations
            echo "Running database migrations..."
            docker compose -f $COMPOSE_FILE exec -T backend php bin/console doctrine:migrations:migrate --no-interaction --allow-no-migration

            # Generate JWT keys
            echo "Generating JWT keys..."
            docker compose -f $COMPOSE_FILE exec -T backend php bin/console lexik:jwt:generate-keypair --skip-if-exists

            # Clearing and warming up cache
            echo "Clearing and warming up cache..."
            docker compose -f $COMPOSE_FILE exec -T backend php bin/console cache:clear --env=prod
            docker compose -f $COMPOSE_FILE exec -T backend php bin/console cache:warmup --env=prod

            # Cleanup all old images on VM
            echo "Cleaning up old images..."
            docker image prune
          EOF
