/* tslint:disable */
/* eslint-disable */
/**
 * Burgieclan API Platform
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnnouncementJsonld
 */
export interface AnnouncementJsonld {
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'content'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'creator'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'startTime'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'endTime'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof AnnouncementJsonld
     */
    'updatedAt'?: any;
}
/**
 * 
 * @export
 * @interface ApiAnnouncementsGetCollection200Response
 */
export interface ApiAnnouncementsGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiAnnouncementsGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiAnnouncementsGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiAnnouncementsGetCollection200ResponseHydraSearch
 */
export interface ApiAnnouncementsGetCollection200ResponseHydraSearch {
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraSearch
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraSearch
     */
    'hydra:template'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraSearch
     */
    'hydra:variableRepresentation'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraSearch
     */
    'hydra:mapping'?: any;
}
/**
 * 
 * @export
 * @interface ApiAnnouncementsGetCollection200ResponseHydraView
 */
export interface ApiAnnouncementsGetCollection200ResponseHydraView {
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraView
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraView
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraView
     */
    'hydra:first'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraView
     */
    'hydra:last'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraView
     */
    'hydra:previous'?: any;
    /**
     * 
     * @type {any}
     * @memberof ApiAnnouncementsGetCollection200ResponseHydraView
     */
    'hydra:next'?: any;
}
/**
 * 
 * @export
 * @interface ApiCommentCategoriesGetCollection200Response
 */
export interface ApiCommentCategoriesGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiCommentCategoriesGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiCommentCategoriesGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiCommentCategoriesGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiCommentCategoriesGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiCourseCommentsGetCollection200Response
 */
export interface ApiCourseCommentsGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiCourseCommentsGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiCourseCommentsGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiCourseCommentsGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiCourseCommentsGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiCoursesGetCollection200Response
 */
export interface ApiCoursesGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiCoursesGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiCoursesGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiCoursesGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiCoursesGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiDocumentCategoriesGetCollection200Response
 */
export interface ApiDocumentCategoriesGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiDocumentCategoriesGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiDocumentCategoriesGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiDocumentCategoriesGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiDocumentCategoriesGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiDocumentCommentsGetCollection200Response
 */
export interface ApiDocumentCommentsGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiDocumentCommentsGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiDocumentCommentsGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiDocumentCommentsGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiDocumentCommentsGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiDocumentsGetCollection200Response
 */
export interface ApiDocumentsGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiDocumentsGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiDocumentsGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiDocumentsGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiDocumentsGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiModulesGetCollection200Response
 */
export interface ApiModulesGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiModulesGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiModulesGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiModulesGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiModulesGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface ApiProgramsGetCollection200Response
 */
export interface ApiProgramsGetCollection200Response {
    /**
     * 
     * @type {any}
     * @memberof ApiProgramsGetCollection200Response
     */
    'hydra:member': any;
    /**
     * 
     * @type {any}
     * @memberof ApiProgramsGetCollection200Response
     */
    'hydra:totalItems'?: any;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraView}
     * @memberof ApiProgramsGetCollection200Response
     */
    'hydra:view'?: ApiAnnouncementsGetCollection200ResponseHydraView;
    /**
     * 
     * @type {ApiAnnouncementsGetCollection200ResponseHydraSearch}
     * @memberof ApiProgramsGetCollection200Response
     */
    'hydra:search'?: ApiAnnouncementsGetCollection200ResponseHydraSearch;
}
/**
 * 
 * @export
 * @interface CommentCategoryJsonld
 */
export interface CommentCategoryJsonld {
    /**
     * 
     * @type {any}
     * @memberof CommentCategoryJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof CommentCategoryJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof CommentCategoryJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof CommentCategoryJsonld
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof CommentCategoryJsonld
     */
    'description'?: any;
}
/**
 * 
 * @export
 * @interface CourseComment
 */
export interface CourseComment {
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'course'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'category'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'content': any;
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'anonymous'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'creator'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseComment
     */
    'updatedAt'?: any;
}
/**
 * 
 * @export
 * @interface CourseCommentJsonld
 */
export interface CourseCommentJsonld {
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'course'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'category'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'content': any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'anonymous'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'creator'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseCommentJsonld
     */
    'updatedAt'?: any;
}
/**
 * 
 * @export
 * @interface CourseJsonld
 */
export interface CourseJsonld {
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'professors'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'semesters'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'credits'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'oldCourses'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'newCourses'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'modules'?: any;
    /**
     * 
     * @type {any}
     * @memberof CourseJsonld
     */
    'courseComments'?: any;
}
/**
 * 
 * @export
 * @interface DocumentCategoryJsonld
 */
export interface DocumentCategoryJsonld {
    /**
     * 
     * @type {any}
     * @memberof DocumentCategoryJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCategoryJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCategoryJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCategoryJsonld
     */
    'name': any;
}
/**
 * 
 * @export
 * @interface DocumentComment
 */
export interface DocumentComment {
    /**
     * 
     * @type {any}
     * @memberof DocumentComment
     */
    'document'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentComment
     */
    'content': any;
    /**
     * 
     * @type {any}
     * @memberof DocumentComment
     */
    'anonymous'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentComment
     */
    'creator'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentComment
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentComment
     */
    'updatedAt'?: any;
}
/**
 * 
 * @export
 * @interface DocumentCommentJsonld
 */
export interface DocumentCommentJsonld {
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    'document'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    'content': any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    'anonymous'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    'creator'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentCommentJsonld
     */
    'updatedAt'?: any;
}
/**
 * 
 * @export
 * @interface DocumentJsonld
 */
export interface DocumentJsonld {
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'course'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'category'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'under_review'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'contentUrl'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'file'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'creator'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof DocumentJsonld
     */
    'updatedAt'?: any;
}
/**
 * 
 * @export
 * @interface LitusAuthenticationJsonld
 */
export interface LitusAuthenticationJsonld {
    /**
     * 
     * @type {any}
     * @memberof LitusAuthenticationJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof LitusAuthenticationJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LitusAuthenticationJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof LitusAuthenticationJsonld
     */
    'accessToken'?: any;
}
/**
 * 
 * @export
 * @interface LoginCheckPost200Response
 */
export interface LoginCheckPost200Response {
    /**
     * 
     * @type {any}
     * @memberof LoginCheckPost200Response
     */
    'token': any;
}
/**
 * 
 * @export
 * @interface LoginCheckPostRequest
 */
export interface LoginCheckPostRequest {
    /**
     * 
     * @type {any}
     * @memberof LoginCheckPostRequest
     */
    'username': any;
    /**
     * 
     * @type {any}
     * @memberof LoginCheckPostRequest
     */
    'password': any;
}
/**
 * 
 * @export
 * @interface ModuleJsonld
 */
export interface ModuleJsonld {
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    'courses'?: any;
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    'modules'?: any;
    /**
     * 
     * @type {any}
     * @memberof ModuleJsonld
     */
    'program'?: any;
}
/**
 * 
 * @export
 * @interface PageJsonld
 */
export interface PageJsonld {
    /**
     * 
     * @type {any}
     * @memberof PageJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof PageJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PageJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof PageJsonld
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof PageJsonld
     */
    'content': any;
    /**
     * 
     * @type {any}
     * @memberof PageJsonld
     */
    'publicAvailable'?: any;
}
/**
 * 
 * @export
 * @interface ProgramJsonld
 */
export interface ProgramJsonld {
    /**
     * 
     * @type {any}
     * @memberof ProgramJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProgramJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProgramJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProgramJsonld
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ProgramJsonld
     */
    'modules'?: any;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'fullName': any;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'username': any;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'favoriteCourses'?: any;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'favoriteModules'?: any;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'favoritePrograms'?: any;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    'favoriteDocuments'?: any;
}
/**
 * 
 * @export
 * @interface UserFavorites
 */
export interface UserFavorites {
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'fullName': any;
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'username': any;
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'favoriteCourses'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'favoriteModules'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'favoritePrograms'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavorites
     */
    'favoriteDocuments'?: any;
}
/**
 * 
 * @export
 * @interface UserFavoritesJsonldUserFavorites
 */
export interface UserFavoritesJsonldUserFavorites {
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    'favoriteCourses'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    'favoriteModules'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    'favoritePrograms'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserFavoritesJsonldUserFavorites
     */
    'favoriteDocuments'?: any;
}
/**
 * 
 * @export
 * @interface UserJsonld
 */
export interface UserJsonld {
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    '@context'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    '@id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    '@type'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'fullName': any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'username': any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'favoriteCourses'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'favoriteModules'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'favoritePrograms'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserJsonld
     */
    'favoriteDocuments'?: any;
}

/**
 * AnnouncementApi - axios parameter creator
 * @export
 */
export const AnnouncementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Announcement resources.
         * @summary Retrieves the collection of Announcement resources.
         * @param {any} [page] The collection page number
         * @param {any} [title] 
         * @param {any} [content] 
         * @param {any} [startTimeBefore] 
         * @param {any} [startTimeStrictlyBefore] 
         * @param {any} [startTimeAfter] 
         * @param {any} [startTimeStrictlyAfter] 
         * @param {any} [endTimeBefore] 
         * @param {any} [endTimeStrictlyBefore] 
         * @param {any} [endTimeAfter] 
         * @param {any} [endTimeStrictlyAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnnouncementsGetCollection: async (page?: any, title?: any, content?: any, startTimeBefore?: any, startTimeStrictlyBefore?: any, startTimeAfter?: any, startTimeStrictlyAfter?: any, endTimeBefore?: any, endTimeStrictlyBefore?: any, endTimeAfter?: any, endTimeStrictlyAfter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (startTimeBefore !== undefined) {
                localVarQueryParameter['startTime[before]'] = startTimeBefore;
            }

            if (startTimeStrictlyBefore !== undefined) {
                localVarQueryParameter['startTime[strictly_before]'] = startTimeStrictlyBefore;
            }

            if (startTimeAfter !== undefined) {
                localVarQueryParameter['startTime[after]'] = startTimeAfter;
            }

            if (startTimeStrictlyAfter !== undefined) {
                localVarQueryParameter['startTime[strictly_after]'] = startTimeStrictlyAfter;
            }

            if (endTimeBefore !== undefined) {
                localVarQueryParameter['endTime[before]'] = endTimeBefore;
            }

            if (endTimeStrictlyBefore !== undefined) {
                localVarQueryParameter['endTime[strictly_before]'] = endTimeStrictlyBefore;
            }

            if (endTimeAfter !== undefined) {
                localVarQueryParameter['endTime[after]'] = endTimeAfter;
            }

            if (endTimeStrictlyAfter !== undefined) {
                localVarQueryParameter['endTime[strictly_after]'] = endTimeStrictlyAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Announcement resource.
         * @summary Retrieves a Announcement resource.
         * @param {any} id Announcement identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnnouncementsIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAnnouncementsIdGet', 'id', id)
            const localVarPath = `/api/announcements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementApi - functional programming interface
 * @export
 */
export const AnnouncementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Announcement resources.
         * @summary Retrieves the collection of Announcement resources.
         * @param {any} [page] The collection page number
         * @param {any} [title] 
         * @param {any} [content] 
         * @param {any} [startTimeBefore] 
         * @param {any} [startTimeStrictlyBefore] 
         * @param {any} [startTimeAfter] 
         * @param {any} [startTimeStrictlyAfter] 
         * @param {any} [endTimeBefore] 
         * @param {any} [endTimeStrictlyBefore] 
         * @param {any} [endTimeAfter] 
         * @param {any} [endTimeStrictlyAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnnouncementsGetCollection(page?: any, title?: any, content?: any, startTimeBefore?: any, startTimeStrictlyBefore?: any, startTimeAfter?: any, startTimeStrictlyAfter?: any, endTimeBefore?: any, endTimeStrictlyBefore?: any, endTimeAfter?: any, endTimeStrictlyAfter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAnnouncementsGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnnouncementsGetCollection(page, title, content, startTimeBefore, startTimeStrictlyBefore, startTimeAfter, startTimeStrictlyAfter, endTimeBefore, endTimeStrictlyBefore, endTimeAfter, endTimeStrictlyAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Announcement resource.
         * @summary Retrieves a Announcement resource.
         * @param {any} id Announcement identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnnouncementsIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnnouncementsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnouncementApi - factory interface
 * @export
 */
export const AnnouncementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Announcement resources.
         * @summary Retrieves the collection of Announcement resources.
         * @param {any} [page] The collection page number
         * @param {any} [title] 
         * @param {any} [content] 
         * @param {any} [startTimeBefore] 
         * @param {any} [startTimeStrictlyBefore] 
         * @param {any} [startTimeAfter] 
         * @param {any} [startTimeStrictlyAfter] 
         * @param {any} [endTimeBefore] 
         * @param {any} [endTimeStrictlyBefore] 
         * @param {any} [endTimeAfter] 
         * @param {any} [endTimeStrictlyAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnnouncementsGetCollection(page?: any, title?: any, content?: any, startTimeBefore?: any, startTimeStrictlyBefore?: any, startTimeAfter?: any, startTimeStrictlyAfter?: any, endTimeBefore?: any, endTimeStrictlyBefore?: any, endTimeAfter?: any, endTimeStrictlyAfter?: any, options?: any): AxiosPromise<ApiAnnouncementsGetCollection200Response> {
            return localVarFp.apiAnnouncementsGetCollection(page, title, content, startTimeBefore, startTimeStrictlyBefore, startTimeAfter, startTimeStrictlyAfter, endTimeBefore, endTimeStrictlyBefore, endTimeAfter, endTimeStrictlyAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Announcement resource.
         * @summary Retrieves a Announcement resource.
         * @param {any} id Announcement identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnnouncementsIdGet(id: any, options?: any): AxiosPromise<AnnouncementJsonld> {
            return localVarFp.apiAnnouncementsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementApi - object-oriented interface
 * @export
 * @class AnnouncementApi
 * @extends {BaseAPI}
 */
export class AnnouncementApi extends BaseAPI {
    /**
     * Retrieves the collection of Announcement resources.
     * @summary Retrieves the collection of Announcement resources.
     * @param {any} [page] The collection page number
     * @param {any} [title] 
     * @param {any} [content] 
     * @param {any} [startTimeBefore] 
     * @param {any} [startTimeStrictlyBefore] 
     * @param {any} [startTimeAfter] 
     * @param {any} [startTimeStrictlyAfter] 
     * @param {any} [endTimeBefore] 
     * @param {any} [endTimeStrictlyBefore] 
     * @param {any} [endTimeAfter] 
     * @param {any} [endTimeStrictlyAfter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementApi
     */
    public apiAnnouncementsGetCollection(page?: any, title?: any, content?: any, startTimeBefore?: any, startTimeStrictlyBefore?: any, startTimeAfter?: any, startTimeStrictlyAfter?: any, endTimeBefore?: any, endTimeStrictlyBefore?: any, endTimeAfter?: any, endTimeStrictlyAfter?: any, options?: AxiosRequestConfig) {
        return AnnouncementApiFp(this.configuration).apiAnnouncementsGetCollection(page, title, content, startTimeBefore, startTimeStrictlyBefore, startTimeAfter, startTimeStrictlyAfter, endTimeBefore, endTimeStrictlyBefore, endTimeAfter, endTimeStrictlyAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Announcement resource.
     * @summary Retrieves a Announcement resource.
     * @param {any} id Announcement identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementApi
     */
    public apiAnnouncementsIdGet(id: any, options?: AxiosRequestConfig) {
        return AnnouncementApiFp(this.configuration).apiAnnouncementsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommentCategoryApi - axios parameter creator
 * @export
 */
export const CommentCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Comment Category resources.
         * @summary Retrieves the collection of Comment Category resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommentCategoriesGetCollection: async (page?: any, name?: any, description?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/comment_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Comment Category resource.
         * @summary Retrieves a Comment Category resource.
         * @param {any} id Comment Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommentCategoriesIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCommentCategoriesIdGet', 'id', id)
            const localVarPath = `/api/comment_categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentCategoryApi - functional programming interface
 * @export
 */
export const CommentCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Comment Category resources.
         * @summary Retrieves the collection of Comment Category resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCommentCategoriesGetCollection(page?: any, name?: any, description?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCommentCategoriesGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCommentCategoriesGetCollection(page, name, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Comment Category resource.
         * @summary Retrieves a Comment Category resource.
         * @param {any} id Comment Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCommentCategoriesIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentCategoryJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCommentCategoriesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentCategoryApi - factory interface
 * @export
 */
export const CommentCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentCategoryApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Comment Category resources.
         * @summary Retrieves the collection of Comment Category resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommentCategoriesGetCollection(page?: any, name?: any, description?: any, options?: any): AxiosPromise<ApiCommentCategoriesGetCollection200Response> {
            return localVarFp.apiCommentCategoriesGetCollection(page, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Comment Category resource.
         * @summary Retrieves a Comment Category resource.
         * @param {any} id Comment Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommentCategoriesIdGet(id: any, options?: any): AxiosPromise<CommentCategoryJsonld> {
            return localVarFp.apiCommentCategoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentCategoryApi - object-oriented interface
 * @export
 * @class CommentCategoryApi
 * @extends {BaseAPI}
 */
export class CommentCategoryApi extends BaseAPI {
    /**
     * Retrieves the collection of Comment Category resources.
     * @summary Retrieves the collection of Comment Category resources.
     * @param {any} [page] The collection page number
     * @param {any} [name] 
     * @param {any} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentCategoryApi
     */
    public apiCommentCategoriesGetCollection(page?: any, name?: any, description?: any, options?: AxiosRequestConfig) {
        return CommentCategoryApiFp(this.configuration).apiCommentCategoriesGetCollection(page, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Comment Category resource.
     * @summary Retrieves a Comment Category resource.
     * @param {any} id Comment Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentCategoryApi
     */
    public apiCommentCategoriesIdGet(id: any, options?: AxiosRequestConfig) {
        return CommentCategoryApiFp(this.configuration).apiCommentCategoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseApi - axios parameter creator
 * @export
 */
export const CourseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Course resources.
         * @summary Retrieves the collection of Course resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoursesGetCollection: async (page?: any, name?: any, code?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Course resource.
         * @summary Retrieves a Course resource.
         * @param {any} id Course identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoursesIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCoursesIdGet', 'id', id)
            const localVarPath = `/api/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseApi - functional programming interface
 * @export
 */
export const CourseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Course resources.
         * @summary Retrieves the collection of Course resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCoursesGetCollection(page?: any, name?: any, code?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCoursesGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoursesGetCollection(page, name, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Course resource.
         * @summary Retrieves a Course resource.
         * @param {any} id Course identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCoursesIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoursesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseApi - factory interface
 * @export
 */
export const CourseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Course resources.
         * @summary Retrieves the collection of Course resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoursesGetCollection(page?: any, name?: any, code?: any, options?: any): AxiosPromise<ApiCoursesGetCollection200Response> {
            return localVarFp.apiCoursesGetCollection(page, name, code, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Course resource.
         * @summary Retrieves a Course resource.
         * @param {any} id Course identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoursesIdGet(id: any, options?: any): AxiosPromise<CourseJsonld> {
            return localVarFp.apiCoursesIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseApi - object-oriented interface
 * @export
 * @class CourseApi
 * @extends {BaseAPI}
 */
export class CourseApi extends BaseAPI {
    /**
     * Retrieves the collection of Course resources.
     * @summary Retrieves the collection of Course resources.
     * @param {any} [page] The collection page number
     * @param {any} [name] 
     * @param {any} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public apiCoursesGetCollection(page?: any, name?: any, code?: any, options?: AxiosRequestConfig) {
        return CourseApiFp(this.configuration).apiCoursesGetCollection(page, name, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Course resource.
     * @summary Retrieves a Course resource.
     * @param {any} id Course identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public apiCoursesIdGet(id: any, options?: AxiosRequestConfig) {
        return CourseApiFp(this.configuration).apiCoursesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseCommentApi - axios parameter creator
 * @export
 */
export const CourseCommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Course Comment resources.
         * @summary Retrieves the collection of Course Comment resources.
         * @param {any} [page] The collection page number
         * @param {any} [content] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [anonymous] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsGetCollection: async (page?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/course_comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (creator2 !== undefined) {
                localVarQueryParameter['creator[]'] = creator2;
            }

            if (anonymous !== undefined) {
                localVarQueryParameter['anonymous'] = anonymous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Course Comment resource.
         * @summary Removes the Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsIdDelete: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCourseCommentsIdDelete', 'id', id)
            const localVarPath = `/api/course_comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Course Comment resource.
         * @summary Retrieves a Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCourseCommentsIdGet', 'id', id)
            const localVarPath = `/api/course_comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Course Comment resource.
         * @summary Updates the Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {CourseComment} courseComment The updated Course Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsIdPatch: async (id: any, courseComment: CourseComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCourseCommentsIdPatch', 'id', id)
            // verify required parameter 'courseComment' is not null or undefined
            assertParamExists('apiCourseCommentsIdPatch', 'courseComment', courseComment)
            const localVarPath = `/api/course_comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Course Comment resource.
         * @summary Creates a Course Comment resource.
         * @param {CourseCommentJsonld} courseCommentJsonld The new Course Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsPost: async (courseCommentJsonld: CourseCommentJsonld, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseCommentJsonld' is not null or undefined
            assertParamExists('apiCourseCommentsPost', 'courseCommentJsonld', courseCommentJsonld)
            const localVarPath = `/api/course_comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseCommentJsonld, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseCommentApi - functional programming interface
 * @export
 */
export const CourseCommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseCommentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Course Comment resources.
         * @summary Retrieves the collection of Course Comment resources.
         * @param {any} [page] The collection page number
         * @param {any} [content] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [anonymous] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCourseCommentsGetCollection(page?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCourseCommentsGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCourseCommentsGetCollection(page, content, creator, creator2, anonymous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Course Comment resource.
         * @summary Removes the Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCourseCommentsIdDelete(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCourseCommentsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Course Comment resource.
         * @summary Retrieves a Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCourseCommentsIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseCommentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCourseCommentsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Course Comment resource.
         * @summary Updates the Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {CourseComment} courseComment The updated Course Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCourseCommentsIdPatch(id: any, courseComment: CourseComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseCommentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCourseCommentsIdPatch(id, courseComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Course Comment resource.
         * @summary Creates a Course Comment resource.
         * @param {CourseCommentJsonld} courseCommentJsonld The new Course Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCourseCommentsPost(courseCommentJsonld: CourseCommentJsonld, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseCommentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCourseCommentsPost(courseCommentJsonld, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseCommentApi - factory interface
 * @export
 */
export const CourseCommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseCommentApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Course Comment resources.
         * @summary Retrieves the collection of Course Comment resources.
         * @param {any} [page] The collection page number
         * @param {any} [content] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [anonymous] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsGetCollection(page?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options?: any): AxiosPromise<ApiCourseCommentsGetCollection200Response> {
            return localVarFp.apiCourseCommentsGetCollection(page, content, creator, creator2, anonymous, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Course Comment resource.
         * @summary Removes the Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsIdDelete(id: any, options?: any): AxiosPromise<void> {
            return localVarFp.apiCourseCommentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Course Comment resource.
         * @summary Retrieves a Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsIdGet(id: any, options?: any): AxiosPromise<CourseCommentJsonld> {
            return localVarFp.apiCourseCommentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Course Comment resource.
         * @summary Updates the Course Comment resource.
         * @param {any} id Course Comment identifier
         * @param {CourseComment} courseComment The updated Course Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsIdPatch(id: any, courseComment: CourseComment, options?: any): AxiosPromise<CourseCommentJsonld> {
            return localVarFp.apiCourseCommentsIdPatch(id, courseComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Course Comment resource.
         * @summary Creates a Course Comment resource.
         * @param {CourseCommentJsonld} courseCommentJsonld The new Course Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCourseCommentsPost(courseCommentJsonld: CourseCommentJsonld, options?: any): AxiosPromise<CourseCommentJsonld> {
            return localVarFp.apiCourseCommentsPost(courseCommentJsonld, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseCommentApi - object-oriented interface
 * @export
 * @class CourseCommentApi
 * @extends {BaseAPI}
 */
export class CourseCommentApi extends BaseAPI {
    /**
     * Retrieves the collection of Course Comment resources.
     * @summary Retrieves the collection of Course Comment resources.
     * @param {any} [page] The collection page number
     * @param {any} [content] 
     * @param {any} [creator] 
     * @param {any} [creator2] 
     * @param {any} [anonymous] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCommentApi
     */
    public apiCourseCommentsGetCollection(page?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options?: AxiosRequestConfig) {
        return CourseCommentApiFp(this.configuration).apiCourseCommentsGetCollection(page, content, creator, creator2, anonymous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Course Comment resource.
     * @summary Removes the Course Comment resource.
     * @param {any} id Course Comment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCommentApi
     */
    public apiCourseCommentsIdDelete(id: any, options?: AxiosRequestConfig) {
        return CourseCommentApiFp(this.configuration).apiCourseCommentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Course Comment resource.
     * @summary Retrieves a Course Comment resource.
     * @param {any} id Course Comment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCommentApi
     */
    public apiCourseCommentsIdGet(id: any, options?: AxiosRequestConfig) {
        return CourseCommentApiFp(this.configuration).apiCourseCommentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Course Comment resource.
     * @summary Updates the Course Comment resource.
     * @param {any} id Course Comment identifier
     * @param {CourseComment} courseComment The updated Course Comment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCommentApi
     */
    public apiCourseCommentsIdPatch(id: any, courseComment: CourseComment, options?: AxiosRequestConfig) {
        return CourseCommentApiFp(this.configuration).apiCourseCommentsIdPatch(id, courseComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Course Comment resource.
     * @summary Creates a Course Comment resource.
     * @param {CourseCommentJsonld} courseCommentJsonld The new Course Comment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCommentApi
     */
    public apiCourseCommentsPost(courseCommentJsonld: CourseCommentJsonld, options?: AxiosRequestConfig) {
        return CourseCommentApiFp(this.configuration).apiCourseCommentsPost(courseCommentJsonld, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Document resources.
         * @summary Retrieves the collection of Document resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [course] 
         * @param {any} [course2] 
         * @param {any} [category] 
         * @param {any} [category2] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [underReview] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsGetCollection: async (page?: any, name?: any, course?: any, course2?: any, category?: any, category2?: any, creator?: any, creator2?: any, underReview?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (course !== undefined) {
                localVarQueryParameter['course'] = course;
            }

            if (course2 !== undefined) {
                localVarQueryParameter['course[]'] = course2;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (category2 !== undefined) {
                localVarQueryParameter['category[]'] = category2;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (creator2 !== undefined) {
                localVarQueryParameter['creator[]'] = creator2;
            }

            if (underReview !== undefined) {
                localVarQueryParameter['under_review'] = underReview;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Document resource.
         * @summary Retrieves a Document resource.
         * @param {any} id Document identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDocumentsIdGet', 'id', id)
            const localVarPath = `/api/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Document resource.
         * @summary Creates a Document resource.
         * @param {any} [name] 
         * @param {any} [course] 
         * @param {any} [category] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsPost: async (name?: any, course?: any, category?: any, file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', new Blob([JSON.stringify(name)], { type: "application/json", }));
            }
    
            if (course !== undefined) { 
                localVarFormParams.append('course', new Blob([JSON.stringify(course)], { type: "application/json", }));
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', new Blob([JSON.stringify(category)], { type: "application/json", }));
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Document resources.
         * @summary Retrieves the collection of Document resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [course] 
         * @param {any} [course2] 
         * @param {any} [category] 
         * @param {any} [category2] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [underReview] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentsGetCollection(page?: any, name?: any, course?: any, course2?: any, category?: any, category2?: any, creator?: any, creator2?: any, underReview?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDocumentsGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentsGetCollection(page, name, course, course2, category, category2, creator, creator2, underReview, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Document resource.
         * @summary Retrieves a Document resource.
         * @param {any} id Document identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentsIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Document resource.
         * @summary Creates a Document resource.
         * @param {any} [name] 
         * @param {any} [course] 
         * @param {any} [category] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentsPost(name?: any, course?: any, category?: any, file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentsPost(name, course, category, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Document resources.
         * @summary Retrieves the collection of Document resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {any} [course] 
         * @param {any} [course2] 
         * @param {any} [category] 
         * @param {any} [category2] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [underReview] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsGetCollection(page?: any, name?: any, course?: any, course2?: any, category?: any, category2?: any, creator?: any, creator2?: any, underReview?: any, options?: any): AxiosPromise<ApiDocumentsGetCollection200Response> {
            return localVarFp.apiDocumentsGetCollection(page, name, course, course2, category, category2, creator, creator2, underReview, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Document resource.
         * @summary Retrieves a Document resource.
         * @param {any} id Document identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsIdGet(id: any, options?: any): AxiosPromise<DocumentJsonld> {
            return localVarFp.apiDocumentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Document resource.
         * @summary Creates a Document resource.
         * @param {any} [name] 
         * @param {any} [course] 
         * @param {any} [category] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentsPost(name?: any, course?: any, category?: any, file?: any, options?: any): AxiosPromise<DocumentJsonld> {
            return localVarFp.apiDocumentsPost(name, course, category, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Retrieves the collection of Document resources.
     * @summary Retrieves the collection of Document resources.
     * @param {any} [page] The collection page number
     * @param {any} [name] 
     * @param {any} [course] 
     * @param {any} [course2] 
     * @param {any} [category] 
     * @param {any} [category2] 
     * @param {any} [creator] 
     * @param {any} [creator2] 
     * @param {any} [underReview] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public apiDocumentsGetCollection(page?: any, name?: any, course?: any, course2?: any, category?: any, category2?: any, creator?: any, creator2?: any, underReview?: any, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).apiDocumentsGetCollection(page, name, course, course2, category, category2, creator, creator2, underReview, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Document resource.
     * @summary Retrieves a Document resource.
     * @param {any} id Document identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public apiDocumentsIdGet(id: any, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).apiDocumentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Document resource.
     * @summary Creates a Document resource.
     * @param {any} [name] 
     * @param {any} [course] 
     * @param {any} [category] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public apiDocumentsPost(name?: any, course?: any, category?: any, file?: any, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).apiDocumentsPost(name, course, category, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentCategoryApi - axios parameter creator
 * @export
 */
export const DocumentCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Document Category resources.
         * @summary Retrieves the collection of Document Category resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCategoriesGetCollection: async (page?: any, name?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/document_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Document Category resource.
         * @summary Retrieves a Document Category resource.
         * @param {any} id Document Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCategoriesIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDocumentCategoriesIdGet', 'id', id)
            const localVarPath = `/api/document_categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentCategoryApi - functional programming interface
 * @export
 */
export const DocumentCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Document Category resources.
         * @summary Retrieves the collection of Document Category resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCategoriesGetCollection(page?: any, name?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDocumentCategoriesGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCategoriesGetCollection(page, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Document Category resource.
         * @summary Retrieves a Document Category resource.
         * @param {any} id Document Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCategoriesIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCategoryJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCategoriesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentCategoryApi - factory interface
 * @export
 */
export const DocumentCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentCategoryApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Document Category resources.
         * @summary Retrieves the collection of Document Category resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCategoriesGetCollection(page?: any, name?: any, options?: any): AxiosPromise<ApiDocumentCategoriesGetCollection200Response> {
            return localVarFp.apiDocumentCategoriesGetCollection(page, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Document Category resource.
         * @summary Retrieves a Document Category resource.
         * @param {any} id Document Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCategoriesIdGet(id: any, options?: any): AxiosPromise<DocumentCategoryJsonld> {
            return localVarFp.apiDocumentCategoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentCategoryApi - object-oriented interface
 * @export
 * @class DocumentCategoryApi
 * @extends {BaseAPI}
 */
export class DocumentCategoryApi extends BaseAPI {
    /**
     * Retrieves the collection of Document Category resources.
     * @summary Retrieves the collection of Document Category resources.
     * @param {any} [page] The collection page number
     * @param {any} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCategoryApi
     */
    public apiDocumentCategoriesGetCollection(page?: any, name?: any, options?: AxiosRequestConfig) {
        return DocumentCategoryApiFp(this.configuration).apiDocumentCategoriesGetCollection(page, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Document Category resource.
     * @summary Retrieves a Document Category resource.
     * @param {any} id Document Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCategoryApi
     */
    public apiDocumentCategoriesIdGet(id: any, options?: AxiosRequestConfig) {
        return DocumentCategoryApiFp(this.configuration).apiDocumentCategoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentCommentApi - axios parameter creator
 * @export
 */
export const DocumentCommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Document Comment resources.
         * @summary Retrieves the collection of Document Comment resources.
         * @param {any} [page] The collection page number
         * @param {any} [document] 
         * @param {any} [document2] 
         * @param {any} [content] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [anonymous] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsGetCollection: async (page?: any, document?: any, document2?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/document_comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (document !== undefined) {
                localVarQueryParameter['document'] = document;
            }

            if (document2 !== undefined) {
                localVarQueryParameter['document[]'] = document2;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (creator2 !== undefined) {
                localVarQueryParameter['creator[]'] = creator2;
            }

            if (anonymous !== undefined) {
                localVarQueryParameter['anonymous'] = anonymous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Document Comment resource.
         * @summary Removes the Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsIdDelete: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDocumentCommentsIdDelete', 'id', id)
            const localVarPath = `/api/document_comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Document Comment resource.
         * @summary Retrieves a Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDocumentCommentsIdGet', 'id', id)
            const localVarPath = `/api/document_comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Document Comment resource.
         * @summary Updates the Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {DocumentComment} documentComment The updated Document Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsIdPatch: async (id: any, documentComment: DocumentComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDocumentCommentsIdPatch', 'id', id)
            // verify required parameter 'documentComment' is not null or undefined
            assertParamExists('apiDocumentCommentsIdPatch', 'documentComment', documentComment)
            const localVarPath = `/api/document_comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Document Comment resource.
         * @summary Creates a Document Comment resource.
         * @param {DocumentCommentJsonld} documentCommentJsonld The new Document Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsPost: async (documentCommentJsonld: DocumentCommentJsonld, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentCommentJsonld' is not null or undefined
            assertParamExists('apiDocumentCommentsPost', 'documentCommentJsonld', documentCommentJsonld)
            const localVarPath = `/api/document_comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCommentJsonld, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentCommentApi - functional programming interface
 * @export
 */
export const DocumentCommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentCommentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Document Comment resources.
         * @summary Retrieves the collection of Document Comment resources.
         * @param {any} [page] The collection page number
         * @param {any} [document] 
         * @param {any} [document2] 
         * @param {any} [content] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [anonymous] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCommentsGetCollection(page?: any, document?: any, document2?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDocumentCommentsGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCommentsGetCollection(page, document, document2, content, creator, creator2, anonymous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Document Comment resource.
         * @summary Removes the Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCommentsIdDelete(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCommentsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Document Comment resource.
         * @summary Retrieves a Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCommentsIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCommentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCommentsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Document Comment resource.
         * @summary Updates the Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {DocumentComment} documentComment The updated Document Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCommentsIdPatch(id: any, documentComment: DocumentComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCommentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCommentsIdPatch(id, documentComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Document Comment resource.
         * @summary Creates a Document Comment resource.
         * @param {DocumentCommentJsonld} documentCommentJsonld The new Document Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDocumentCommentsPost(documentCommentJsonld: DocumentCommentJsonld, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCommentJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDocumentCommentsPost(documentCommentJsonld, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentCommentApi - factory interface
 * @export
 */
export const DocumentCommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentCommentApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Document Comment resources.
         * @summary Retrieves the collection of Document Comment resources.
         * @param {any} [page] The collection page number
         * @param {any} [document] 
         * @param {any} [document2] 
         * @param {any} [content] 
         * @param {any} [creator] 
         * @param {any} [creator2] 
         * @param {any} [anonymous] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsGetCollection(page?: any, document?: any, document2?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options?: any): AxiosPromise<ApiDocumentCommentsGetCollection200Response> {
            return localVarFp.apiDocumentCommentsGetCollection(page, document, document2, content, creator, creator2, anonymous, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Document Comment resource.
         * @summary Removes the Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsIdDelete(id: any, options?: any): AxiosPromise<void> {
            return localVarFp.apiDocumentCommentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Document Comment resource.
         * @summary Retrieves a Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsIdGet(id: any, options?: any): AxiosPromise<DocumentCommentJsonld> {
            return localVarFp.apiDocumentCommentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Document Comment resource.
         * @summary Updates the Document Comment resource.
         * @param {any} id Document Comment identifier
         * @param {DocumentComment} documentComment The updated Document Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsIdPatch(id: any, documentComment: DocumentComment, options?: any): AxiosPromise<DocumentCommentJsonld> {
            return localVarFp.apiDocumentCommentsIdPatch(id, documentComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Document Comment resource.
         * @summary Creates a Document Comment resource.
         * @param {DocumentCommentJsonld} documentCommentJsonld The new Document Comment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDocumentCommentsPost(documentCommentJsonld: DocumentCommentJsonld, options?: any): AxiosPromise<DocumentCommentJsonld> {
            return localVarFp.apiDocumentCommentsPost(documentCommentJsonld, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentCommentApi - object-oriented interface
 * @export
 * @class DocumentCommentApi
 * @extends {BaseAPI}
 */
export class DocumentCommentApi extends BaseAPI {
    /**
     * Retrieves the collection of Document Comment resources.
     * @summary Retrieves the collection of Document Comment resources.
     * @param {any} [page] The collection page number
     * @param {any} [document] 
     * @param {any} [document2] 
     * @param {any} [content] 
     * @param {any} [creator] 
     * @param {any} [creator2] 
     * @param {any} [anonymous] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCommentApi
     */
    public apiDocumentCommentsGetCollection(page?: any, document?: any, document2?: any, content?: any, creator?: any, creator2?: any, anonymous?: any, options?: AxiosRequestConfig) {
        return DocumentCommentApiFp(this.configuration).apiDocumentCommentsGetCollection(page, document, document2, content, creator, creator2, anonymous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Document Comment resource.
     * @summary Removes the Document Comment resource.
     * @param {any} id Document Comment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCommentApi
     */
    public apiDocumentCommentsIdDelete(id: any, options?: AxiosRequestConfig) {
        return DocumentCommentApiFp(this.configuration).apiDocumentCommentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Document Comment resource.
     * @summary Retrieves a Document Comment resource.
     * @param {any} id Document Comment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCommentApi
     */
    public apiDocumentCommentsIdGet(id: any, options?: AxiosRequestConfig) {
        return DocumentCommentApiFp(this.configuration).apiDocumentCommentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Document Comment resource.
     * @summary Updates the Document Comment resource.
     * @param {any} id Document Comment identifier
     * @param {DocumentComment} documentComment The updated Document Comment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCommentApi
     */
    public apiDocumentCommentsIdPatch(id: any, documentComment: DocumentComment, options?: AxiosRequestConfig) {
        return DocumentCommentApiFp(this.configuration).apiDocumentCommentsIdPatch(id, documentComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Document Comment resource.
     * @summary Creates a Document Comment resource.
     * @param {DocumentCommentJsonld} documentCommentJsonld The new Document Comment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentCommentApi
     */
    public apiDocumentCommentsPost(documentCommentJsonld: DocumentCommentJsonld, options?: AxiosRequestConfig) {
        return DocumentCommentApiFp(this.configuration).apiDocumentCommentsPost(documentCommentJsonld, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LitusAuthenticationApi - axios parameter creator
 * @export
 */
export const LitusAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Litus Authentication resource.
         * @summary Creates a Litus Authentication resource.
         * @param {LitusAuthenticationJsonld} litusAuthenticationJsonld The new Litus Authentication resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        litusAuthentication: async (litusAuthenticationJsonld: LitusAuthenticationJsonld, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'litusAuthenticationJsonld' is not null or undefined
            assertParamExists('litusAuthentication', 'litusAuthenticationJsonld', litusAuthenticationJsonld)
            const localVarPath = `/api/auth/litus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(litusAuthenticationJsonld, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LitusAuthenticationApi - functional programming interface
 * @export
 */
export const LitusAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LitusAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Litus Authentication resource.
         * @summary Creates a Litus Authentication resource.
         * @param {LitusAuthenticationJsonld} litusAuthenticationJsonld The new Litus Authentication resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async litusAuthentication(litusAuthenticationJsonld: LitusAuthenticationJsonld, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LitusAuthenticationJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.litusAuthentication(litusAuthenticationJsonld, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LitusAuthenticationApi - factory interface
 * @export
 */
export const LitusAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LitusAuthenticationApiFp(configuration)
    return {
        /**
         * Creates a Litus Authentication resource.
         * @summary Creates a Litus Authentication resource.
         * @param {LitusAuthenticationJsonld} litusAuthenticationJsonld The new Litus Authentication resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        litusAuthentication(litusAuthenticationJsonld: LitusAuthenticationJsonld, options?: any): AxiosPromise<LitusAuthenticationJsonld> {
            return localVarFp.litusAuthentication(litusAuthenticationJsonld, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LitusAuthenticationApi - object-oriented interface
 * @export
 * @class LitusAuthenticationApi
 * @extends {BaseAPI}
 */
export class LitusAuthenticationApi extends BaseAPI {
    /**
     * Creates a Litus Authentication resource.
     * @summary Creates a Litus Authentication resource.
     * @param {LitusAuthenticationJsonld} litusAuthenticationJsonld The new Litus Authentication resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LitusAuthenticationApi
     */
    public litusAuthentication(litusAuthenticationJsonld: LitusAuthenticationJsonld, options?: AxiosRequestConfig) {
        return LitusAuthenticationApiFp(this.configuration).litusAuthentication(litusAuthenticationJsonld, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginCheckApi - axios parameter creator
 * @export
 */
export const LoginCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a user token.
         * @summary Creates a user token.
         * @param {LoginCheckPostRequest} loginCheckPostRequest The login data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckPost: async (loginCheckPostRequest: LoginCheckPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCheckPostRequest' is not null or undefined
            assertParamExists('loginCheckPost', 'loginCheckPostRequest', loginCheckPostRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCheckPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginCheckApi - functional programming interface
 * @export
 */
export const LoginCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a user token.
         * @summary Creates a user token.
         * @param {LoginCheckPostRequest} loginCheckPostRequest The login data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheckPost(loginCheckPostRequest: LoginCheckPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginCheckPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheckPost(loginCheckPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginCheckApi - factory interface
 * @export
 */
export const LoginCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginCheckApiFp(configuration)
    return {
        /**
         * Creates a user token.
         * @summary Creates a user token.
         * @param {LoginCheckPostRequest} loginCheckPostRequest The login data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckPost(loginCheckPostRequest: LoginCheckPostRequest, options?: any): AxiosPromise<LoginCheckPost200Response> {
            return localVarFp.loginCheckPost(loginCheckPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginCheckApi - object-oriented interface
 * @export
 * @class LoginCheckApi
 * @extends {BaseAPI}
 */
export class LoginCheckApi extends BaseAPI {
    /**
     * Creates a user token.
     * @summary Creates a user token.
     * @param {LoginCheckPostRequest} loginCheckPostRequest The login data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginCheckApi
     */
    public loginCheckPost(loginCheckPostRequest: LoginCheckPostRequest, options?: AxiosRequestConfig) {
        return LoginCheckApiFp(this.configuration).loginCheckPost(loginCheckPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModuleApi - axios parameter creator
 * @export
 */
export const ModuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Module resources.
         * @summary Retrieves the collection of Module resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModulesGetCollection: async (page?: any, name?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Module resource.
         * @summary Retrieves a Module resource.
         * @param {any} id Module identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModulesIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiModulesIdGet', 'id', id)
            const localVarPath = `/api/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleApi - functional programming interface
 * @export
 */
export const ModuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Module resources.
         * @summary Retrieves the collection of Module resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiModulesGetCollection(page?: any, name?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiModulesGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiModulesGetCollection(page, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Module resource.
         * @summary Retrieves a Module resource.
         * @param {any} id Module identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiModulesIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiModulesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModuleApi - factory interface
 * @export
 */
export const ModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModuleApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Module resources.
         * @summary Retrieves the collection of Module resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModulesGetCollection(page?: any, name?: any, options?: any): AxiosPromise<ApiModulesGetCollection200Response> {
            return localVarFp.apiModulesGetCollection(page, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Module resource.
         * @summary Retrieves a Module resource.
         * @param {any} id Module identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModulesIdGet(id: any, options?: any): AxiosPromise<ModuleJsonld> {
            return localVarFp.apiModulesIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModuleApi - object-oriented interface
 * @export
 * @class ModuleApi
 * @extends {BaseAPI}
 */
export class ModuleApi extends BaseAPI {
    /**
     * Retrieves the collection of Module resources.
     * @summary Retrieves the collection of Module resources.
     * @param {any} [page] The collection page number
     * @param {any} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public apiModulesGetCollection(page?: any, name?: any, options?: AxiosRequestConfig) {
        return ModuleApiFp(this.configuration).apiModulesGetCollection(page, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Module resource.
     * @summary Retrieves a Module resource.
     * @param {any} id Module identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public apiModulesIdGet(id: any, options?: AxiosRequestConfig) {
        return ModuleApiFp(this.configuration).apiModulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a Page resource.
         * @summary Retrieves a Page resource.
         * @param {any} urlKey Page identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPagesUrlKeyGet: async (urlKey: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'urlKey' is not null or undefined
            assertParamExists('apiPagesUrlKeyGet', 'urlKey', urlKey)
            const localVarPath = `/api/pages/{urlKey}`
                .replace(`{${"urlKey"}}`, encodeURIComponent(String(urlKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a Page resource.
         * @summary Retrieves a Page resource.
         * @param {any} urlKey Page identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPagesUrlKeyGet(urlKey: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPagesUrlKeyGet(urlKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageApiFp(configuration)
    return {
        /**
         * Retrieves a Page resource.
         * @summary Retrieves a Page resource.
         * @param {any} urlKey Page identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPagesUrlKeyGet(urlKey: any, options?: any): AxiosPromise<PageJsonld> {
            return localVarFp.apiPagesUrlKeyGet(urlKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     * Retrieves a Page resource.
     * @summary Retrieves a Page resource.
     * @param {any} urlKey Page identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public apiPagesUrlKeyGet(urlKey: any, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).apiPagesUrlKeyGet(urlKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProgramApi - axios parameter creator
 * @export
 */
export const ProgramApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Program resources.
         * @summary Retrieves the collection of Program resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProgramsGetCollection: async (page?: any, name?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Program resource.
         * @summary Retrieves a Program resource.
         * @param {any} id Program identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProgramsIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProgramsIdGet', 'id', id)
            const localVarPath = `/api/programs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramApi - functional programming interface
 * @export
 */
export const ProgramApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Program resources.
         * @summary Retrieves the collection of Program resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProgramsGetCollection(page?: any, name?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiProgramsGetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProgramsGetCollection(page, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Program resource.
         * @summary Retrieves a Program resource.
         * @param {any} id Program identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProgramsIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProgramsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProgramApi - factory interface
 * @export
 */
export const ProgramApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Program resources.
         * @summary Retrieves the collection of Program resources.
         * @param {any} [page] The collection page number
         * @param {any} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProgramsGetCollection(page?: any, name?: any, options?: any): AxiosPromise<ApiProgramsGetCollection200Response> {
            return localVarFp.apiProgramsGetCollection(page, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Program resource.
         * @summary Retrieves a Program resource.
         * @param {any} id Program identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProgramsIdGet(id: any, options?: any): AxiosPromise<ProgramJsonld> {
            return localVarFp.apiProgramsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramApi - object-oriented interface
 * @export
 * @class ProgramApi
 * @extends {BaseAPI}
 */
export class ProgramApi extends BaseAPI {
    /**
     * Retrieves the collection of Program resources.
     * @summary Retrieves the collection of Program resources.
     * @param {any} [page] The collection page number
     * @param {any} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public apiProgramsGetCollection(page?: any, name?: any, options?: AxiosRequestConfig) {
        return ProgramApiFp(this.configuration).apiProgramsGetCollection(page, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Program resource.
     * @summary Retrieves a Program resource.
     * @param {any} id Program identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public apiProgramsIdGet(id: any, options?: AxiosRequestConfig) {
        return ProgramApiFp(this.configuration).apiProgramsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {any} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {any} id User identifier
         * @param {User} user The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch: async (id: any, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'user', user)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {any} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {any} id User identifier
         * @param {User} user The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPatch(id: any, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJsonld>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdPatch(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {any} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: any, options?: any): AxiosPromise<UserJsonld> {
            return localVarFp.apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {any} id User identifier
         * @param {User} user The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch(id: any, user: User, options?: any): AxiosPromise<UserJsonld> {
            return localVarFp.apiUsersIdPatch(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {any} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdGet(id: any, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {any} id User identifier
     * @param {User} user The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdPatch(id: any, user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdPatch(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserFavoritesApi - axios parameter creator
 * @export
 */
export const UserFavoritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a User favorites resource.
         * @summary Retrieves a User favorites resource.
         * @param {any} id User favorites identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdfavoritesGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdfavoritesGet', 'id', id)
            const localVarPath = `/api/users/{id}/favorites`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User favorites resource.
         * @summary Updates the User favorites resource.
         * @param {any} id User favorites identifier
         * @param {UserFavorites} userFavorites The updated User favorites resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdfavoritesaddPatch: async (id: any, userFavorites: UserFavorites, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdfavoritesaddPatch', 'id', id)
            // verify required parameter 'userFavorites' is not null or undefined
            assertParamExists('apiUsersIdfavoritesaddPatch', 'userFavorites', userFavorites)
            const localVarPath = `/api/users/{id}/favorites/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userFavorites, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User favorites resource.
         * @summary Updates the User favorites resource.
         * @param {any} id User favorites identifier
         * @param {UserFavorites} userFavorites The updated User favorites resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdfavoritesremovePatch: async (id: any, userFavorites: UserFavorites, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdfavoritesremovePatch', 'id', id)
            // verify required parameter 'userFavorites' is not null or undefined
            assertParamExists('apiUsersIdfavoritesremovePatch', 'userFavorites', userFavorites)
            const localVarPath = `/api/users/{id}/favorites/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userFavorites, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserFavoritesApi - functional programming interface
 * @export
 */
export const UserFavoritesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserFavoritesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a User favorites resource.
         * @summary Retrieves a User favorites resource.
         * @param {any} id User favorites identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdfavoritesGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFavoritesJsonldUserFavorites>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdfavoritesGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the User favorites resource.
         * @summary Updates the User favorites resource.
         * @param {any} id User favorites identifier
         * @param {UserFavorites} userFavorites The updated User favorites resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdfavoritesaddPatch(id: any, userFavorites: UserFavorites, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFavoritesJsonldUserFavorites>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdfavoritesaddPatch(id, userFavorites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the User favorites resource.
         * @summary Updates the User favorites resource.
         * @param {any} id User favorites identifier
         * @param {UserFavorites} userFavorites The updated User favorites resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdfavoritesremovePatch(id: any, userFavorites: UserFavorites, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFavoritesJsonldUserFavorites>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdfavoritesremovePatch(id, userFavorites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserFavoritesApi - factory interface
 * @export
 */
export const UserFavoritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserFavoritesApiFp(configuration)
    return {
        /**
         * Retrieves a User favorites resource.
         * @summary Retrieves a User favorites resource.
         * @param {any} id User favorites identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdfavoritesGet(id: any, options?: any): AxiosPromise<UserFavoritesJsonldUserFavorites> {
            return localVarFp.apiUsersIdfavoritesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User favorites resource.
         * @summary Updates the User favorites resource.
         * @param {any} id User favorites identifier
         * @param {UserFavorites} userFavorites The updated User favorites resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdfavoritesaddPatch(id: any, userFavorites: UserFavorites, options?: any): AxiosPromise<UserFavoritesJsonldUserFavorites> {
            return localVarFp.apiUsersIdfavoritesaddPatch(id, userFavorites, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User favorites resource.
         * @summary Updates the User favorites resource.
         * @param {any} id User favorites identifier
         * @param {UserFavorites} userFavorites The updated User favorites resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdfavoritesremovePatch(id: any, userFavorites: UserFavorites, options?: any): AxiosPromise<UserFavoritesJsonldUserFavorites> {
            return localVarFp.apiUsersIdfavoritesremovePatch(id, userFavorites, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserFavoritesApi - object-oriented interface
 * @export
 * @class UserFavoritesApi
 * @extends {BaseAPI}
 */
export class UserFavoritesApi extends BaseAPI {
    /**
     * Retrieves a User favorites resource.
     * @summary Retrieves a User favorites resource.
     * @param {any} id User favorites identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFavoritesApi
     */
    public apiUsersIdfavoritesGet(id: any, options?: AxiosRequestConfig) {
        return UserFavoritesApiFp(this.configuration).apiUsersIdfavoritesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User favorites resource.
     * @summary Updates the User favorites resource.
     * @param {any} id User favorites identifier
     * @param {UserFavorites} userFavorites The updated User favorites resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFavoritesApi
     */
    public apiUsersIdfavoritesaddPatch(id: any, userFavorites: UserFavorites, options?: AxiosRequestConfig) {
        return UserFavoritesApiFp(this.configuration).apiUsersIdfavoritesaddPatch(id, userFavorites, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User favorites resource.
     * @summary Updates the User favorites resource.
     * @param {any} id User favorites identifier
     * @param {UserFavorites} userFavorites The updated User favorites resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFavoritesApi
     */
    public apiUsersIdfavoritesremovePatch(id: any, userFavorites: UserFavorites, options?: AxiosRequestConfig) {
        return UserFavoritesApiFp(this.configuration).apiUsersIdfavoritesremovePatch(id, userFavorites, options).then((request) => request(this.axios, this.basePath));
    }
}


